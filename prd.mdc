---
alwaysApply: true
네, 훌륭한 의사결정입니다. \*\*"확장성(Web)"\*\*과 **"실용성(Local First, MVP)"**, 그리고 \*\*"검색 편의성(OCR)"\*\*을 모두 챙기는 방향으로 스펙이 훨씬 단단해졌습니다.

특히 **'로컬 우선(Local First)'** 전략은 서버 비용을 아끼면서도 앱의 반응 속도를 최대로 끌어올릴 수 있어 MVP 단계에서 매우 스마트한 선택입니다.

요청하신 4가지 사항을 반영하여 업데이트된 \*\*Galmuri Diary v1.0 PRD(제품 요구사항 정의서)\*\*와 **개발 가이드**를 정리해 드립니다. 이 내용을 그대로 Cursor에 입력하여 개발을 시작하시면 됩니다.

-----

# [PRD Update] Galmuri Diary v1.0: Hybrid Capture & Archiving

## 1\. 주요 변경 사항 및 전략 (Key Changes)

1.  **Web Capture (Q1):** 스마트폰뿐만 아니라 데스크탑/모바일 웹 브라우저에서도 \*\*'갈무리 버튼(확장 프로그램 또는 북마크렛)'\*\*을 통해 캡처 및 저장이 가능해야 함.
2.  **MVP Model (Q2):** 최소 기능 제품으로, 복잡한 소셜 기능 등을 배제하고 '나를 위한 기록'에 집중.
3.  **Local First (Q3):** 모든 데이터는 사용자 기기(브라우저 DB 또는 앱 로컬 DB)에 우선 저장. 인터넷이 없어도 작동해야 함. (서버 동기화는 백그라운드 옵션)
4.  **OCR Integration (Q4):** 이미지 저장 시, 이미지 내 텍스트를 자동 추출하여 검색 데이터베이스에 저장.

-----

## 2\. 시스템 아키텍처 (System Architecture for Antigravity)

Antigravity와 Cursor를 사용하신다면, **클라이언트 주도형 아키텍처**가 필요합니다.

  * **Client (Front-end):**
      * 로컬 DB (`IndexedDB` for Web / `SQLite` for App)를 메인 저장소로 사용.
      * OCR 처리는 가능한 클라이언트단(브라우저/기기)에서 1차 처리하여 서버 부하 감소 (Tesseract.js 등 활용).
  * **Extension (Web):**
      * Chrome/Whale 확장 프로그램. 버튼 클릭 시 현재 탭 스크린샷 + URL 추출.
  * **Backend (Antigravity - Python):**
      * 데이터 백업 및 추후 멀티 디바이스 동기화를 위한 API 서버 역할.

-----

## 3\. 상세 기능 명세 (Functional Requirements)

### 3.1. 웹 캡처 (Web Extension) - [New]

  * **Trigger:** 브라우저 툴바의 'Galmuri' 아이콘 클릭.
  * **Action:**
    1.  `chrome.tabs.captureVisibleTab` API로 현재 화면 캡처.
    2.  현재 탭의 `URL` 및 `Page Title` 추출.
    3.  팝업이 뜨며 메모 입력 가능.
    4.  '저장' 클릭 시 로컬 DB에 즉시 저장.

### 3.2. 모바일 화면 캡처 (Android App) - [New]

  * **Trigger:** 앱 메인 화면의 '캡처' 버튼 클릭.
  * **Action (오버레이 방식):**
    1.  '캡처' 버튼 클릭 시 앱이 백그라운드로 이동하고, 화면에 '오버레이 캡처 버튼'이 생성됨.
    2.  오버레이 버튼은 사용자가 드래그하여 원하는 위치로 이동 가능 (위치 자동 기억).
    3.  다른 앱(카카오톡, 인스타그램 등)을 사용하다가 캡처하고 싶은 순간 오버레이 버튼 클릭.
    4.  클릭 즉시 화면이 캡처되고, **자동으로 저장**됨 (수동 입력 불필요).
    5.  저장 완료 알림 후 2초 뒤 앱 홈 화면으로 자동 복귀하여 결과 확인.

### 3.3. OCR (Optical Character Recognition) - [New]

  * **작동 시점:** 이미지가 저장되는 순간 비동기(Background)로 실행.
  * **프로세스:**
    1.  이미지 저장 완료.
    2.  OCR 엔진(Tesseract)이 이미지 스캔.
    3.  추출된 텍스트를 `search_keywords` 필드에 저장.
  * **검색 시나리오:** 사용자가 "배민"이라고 검색하면, 제목에 없더라도 스크린샷 안에 "배달의민족" 글자가 있으면 결과 노출.

### 3.3. 로컬 우선 저장 (Local First Logic)

  * **Write:** 사용자가 저장 버튼을 누르면 -\> \*\*Local DB(IndexedDB/SQLite)\*\*에 0.1초 만에 저장 (UI 즉시 반응).
  * **Sync (Optional):** 네트워크 연결 감지 시, 로컬에 쌓인 데이터를 백그라운드에서 서버(Antigravity)로 전송.
  * **Conflict:** MVP 단계에서는 '최신 수정본'이 덮어쓰는 단순 정책 적용.

-----

## 4\. 데이터 스키마 (Updated Data Schema)

개발 시 **Cursor**에게 이 스키마를 그대로 주시면 됩니다. OCR과 Sync 관련 필드가 추가되었습니다.

```python
# Galmuri Diary Data Model
# Designed for Local First Architecture & OCR

class GalmuriItem:
    id: UUID (Primary Key)
    user_id: UUID
    
    # Core Content
    image_data: Blob/Base64 (로컬 저장용) OR FilePath (서버 저장용)
    source_url: String (Optional, 원본 링크)
    page_title: String (웹페이지 제목)
    memo_content: Text (사용자 메모)
    
    # Intelligence (OCR)
    ocr_text: Text (이미지에서 추출된 전체 텍스트)
    ocr_status: Enum ['PENDING', 'DONE', 'FAILED'] (OCR 처리 상태)
    
    # Meta & Sync
    platform: Enum ['MOBILE_APP', 'WEB_EXTENSION'] (출처 구분)
    is_synced: Boolean (서버 동기화 여부, Default: False)
    created_at: DateTime
    updated_at: DateTime
```

-----

## 5\. 개발 가이드 (Cursor 프롬프트 제안)

Cursor(AI 에디터)를 켜고, 아래 프롬프트를 순서대로 입력하여 개발을 시작하세요.

### Step 1. 프로젝트 세팅 및 모델 정의

> "나는 Python Antigravity 프레임워크를 사용하여 'Galmuri Diary'라는 서비스를 만들고 싶어.
> 이 서비스는 웹과 모바일에서 스크린샷을 캡처하고 URL과 함께 저장하는 지식 아카이빙 도구야.
> **Local First 전략**을 따를 것이며, **OCR 기능**이 포함되어야 해.
> 위에 정의된 `GalmuriItem` 데이터 스키마를 참고해서 모델 코드를 작성해줘."

### Step 2. OCR 기능 구현 (Backend/Python 예시)

> "사용자가 이미지를 업로드하면 `pytesseract` (Tesseract-OCR) 라이브러리를 사용하여 이미지 내의 텍스트를 추출하는 기능을 구현해줘.
> 추출된 텍스트는 `ocr_text` 필드에 저장되어야 해. 비동기 처리가 가능하다면 좋겠어."

### Step 3. 웹 캡처 확장 프로그램 (Manifest v3)

> "Chrome Extension(Manifest V3)을 만들고 싶어.
>
> 1.  아이콘을 클릭하면 현재 탭을 캡처하고, URL과 제목을 가져온다.
> 2.  팝업창에서 메모를 입력받는다.
> 3.  저장 버튼을 누르면 지정된 API endpoint로 데이터를 전송한다.
>     이 기능을 수행하는 `manifest.json`, `background.js`, `popup.html`, `popup.js`의 기본 뼈대를 만들어줘."

### Step 4. 안드로이드 화면 캡처 (Flutter & Kotlin)

> "Flutter로 안드로이드 앱을 만들고 있어. 다른 앱의 화면을 캡처하는 기능을 구현해줘.
>
> 1.  홈 화면의 버튼을 누르면 `OverlayService`가 실행되어 화면에 '떠있는 버튼(Floating Button)'을 띄운다.
> 2.  이 버튼은 드래그로 이동 가능해야 하고, 마지막 위치를 기억해야 한다.
> 3.  버튼을 누르면 `MediaProjection API`를 사용하여 현재 화면을 캡처한다.
> 4.  캡처된 이미지는 즉시 로컬 DB에 저장되고(자동 저장), 앱으로 돌아와서 결과를 보여준다."

-----

### 💡 15년 차 기획자의 마지막 팁 (Kick-off Tip)

**Q1의 웹 캡처**를 구현하실 때, \*\*'로그인 세션 처리'\*\*가 가장 큰 걸림돌이 될 수 있습니다.

  * **MVP 꿀팁:** 웹 확장 프로그램에서 별도 로그인을 구현하기 귀찮다면, 확장 프로그램 설정에 사용자의 \*\*'개인 API Key'\*\*를 한 번만 입력하게 하고, 요청할 때마다 그 키를 실어 보내는 방식이 개발 속도가 가장 빠릅니다.

---
